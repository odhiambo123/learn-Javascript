<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{color:#29303b;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.5pt;font-family:"Arial";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{padding-top:0pt;padding-bottom:8pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{background-color:#e6f2f5}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5"><p class="c0"><span class="c1">We&#39;ve talked quite a bit about what a function really is.</span></p><p class="c0"><span class="c1">It&#39;s an object with properties and various things that happen.</span></p><p class="c0"><span class="c1">Now it&#39;s time to take a step back and look again at what happens when</span></p><p class="c0"><span class="c1">the code of a function is invoked, when a function is Run.</span></p><p class="c0"><span class="c1">Remember those execution contexts that we talked about</span></p><p class="c0"><span class="c1">at the beginning of the course.</span></p><p class="c0"><span class="c1">So this is Objects, Functions and the sometimes confusing keyword this.</span></p><p class="c0"><span class="c1">Just as a reminder,</span></p><p class="c0"><span class="c1">when a function is invoked a new execution context is created.</span></p><p class="c0"><span class="c1">Remember not to confuse this with the object that we&#39;ve been discussing.</span></p><p class="c0"><span class="c1">The object sitting in memory that is a function has properties and methods.</span></p><p class="c0"><span class="c1">It has a name property and a code property where the code lives.</span></p><p class="c0"><span class="c1">But when that code is invoked and</span></p><p class="c0"><span class="c1">execution context is created and put on the execution stack.</span></p><p class="c0"><span class="c1">And that determines how that code is Run, is executed.</span></p><p class="c0"><span class="c1">So think of the execution context</span></p><p class="c0"><span class="c1">as focusing on that code portion of that function object.</span></p><p class="c0"><span class="c1">What happens when I run the code in that code property?</span></p><p class="c0"><span class="c1">So we know that an execution context is created.</span></p><p class="c0"><span class="c1">Each executions context has this variable environment.</span></p><p class="c0"><span class="c1">Where the variables created inside that function live.</span></p><p class="c0"><span class="c1">It has a reference to its outer environment.</span></p><p class="c0"><span class="c1">Its outer lexical environment, where it sits physically in the code,</span></p><p class="c0"><span class="c1">which tells it how to look down the scope chain.</span></p><p class="c0"><span class="c1">In other words, if I ask for a variable and</span></p><p class="c0"><span class="c1">it&#39;s not there inside that function&#39;s variable environment.</span></p><p class="c0"><span class="c1">It&#39;ll go out and out further, and all the way out until it reaches the global</span></p><p class="c0"><span class="c1">environment looking for that variable or that function.</span></p><p class="c0"><span class="c1">So it has that outer reference.</span></p><p class="c0"><span class="c1">And we also know that in JavaScript engine every time</span></p><p class="c0"><span class="c1">an execution context is created, that is every time a function is Run.</span></p><p class="c0"><span class="c1">It gives us, without us having to create it, declare it or</span></p><p class="c0"><span class="c1">anything, it gives us this variable called this, which can be useful.</span></p><p class="c0"><span class="c1">And this will be pointing at a different object,</span></p><p class="c0"><span class="c1">a different thing, depending on how the function is invoked.</span></p><p class="c0"><span class="c1">This can cause a lot of confusion.</span></p><p class="c0"><span class="c1">There are a few scenarios where this</span></p><p class="c0"><span class="c1">will be changed depending on how the function is called.</span></p><p class="c0"><span class="c1">For the JavaScript engine will decide that this should point to something different.</span></p><p class="c0"><span class="c1">That the this keyword is a particular object or another,</span></p><p class="c0"><span class="c1">depending on where the function is and how it&#39;s called.</span></p><p class="c0"><span class="c1">So let&#39;s take a look at a couple of these scenarios, and</span></p><p class="c0"><span class="c1">we&#39;ll see this again later in the course as well.</span></p><p class="c0"><span class="c1">So, the this keyword.</span></p><p class="c0"><span class="c1">I once again have my empty app.js file, and</span></p><p class="c0"><span class="c1">we&#39;ll use some simple examples to explain what this,</span></p><p class="c0"><span class="c1">the keyword this will be under certain circumstances.</span></p><p class="c0"><span class="c1">Now you maybe thinking that you&#39;d like to see some more concrete complete examples.</span></p><p class="c0"><span class="c1">I agree.</span></p><p class="c0"><span class="c1">As this course goes on especially toward the end, we&#39;ll look at far more complex</span></p><p class="c0"><span class="c1">examples of the concepts that we&#39;re using in the real world and</span></p><p class="c0"><span class="c1">in very popular JavaScript libraries and frameworks.</span></p><p class="c0"><span class="c1 c3">But I believe it&#39;s important first to understand the concept and</span></p><p class="c0"><span class="c1">not get bogged down in the details of implementation of more complex examples.</span></p><p class="c0"><span class="c1">So right now we&#39;re focusing on just</span></p><p class="c0"><span class="c1">understanding what&#39;s happening under the hood with JavaScript.</span></p><p class="c0"><span class="c1">And then later we&#39;ll build on that knowledge with more complex example.</span></p><p class="c0"><span class="c1">For now, let&#39;s move on talking about this keyword.</span></p><p class="c0"><span class="c1">We&#39;ve already seen that this is immediately available, the keyword this.</span></p><p class="c0"><span class="c1">Even at the global execution context level.</span></p><p class="c0"><span class="c1">So I can run this, and inside the browser, it&#39;s going to show me the window object.</span></p><p class="c0"><span class="c1">Because this points to the global object at this level in the code.</span></p><p class="c0"><span class="c1">And inside the browser, the global object is,</span></p><p class="c0"><span class="c1">as you might recall, the Window object.</span></p><p class="c0"><span class="c1">Now let&#39;s look at another example, let&#39;s say I have a function.</span></p><p class="c0"><span class="c1">I&#39;ll just call it a, and I&#39;m going to log this.</span></p><p class="c0"><span class="c1">And then, I&#39;ll invoke a.</span></p><p class="c0"><span class="c1">Remember that invoking a, means run that code property</span></p><p class="c0"><span class="c1">which contains all the lines of code inside the function.</span></p><p class="c0"><span class="c1">And the first thing it does is create that execution context, and one of that</span></p><p class="c0"><span class="c1">pieces of the puzzle is the creation of the keyword this.</span></p><p class="c0"><span class="c1">So what will the keyword this be</span></p><p class="c0"><span class="c1">inside the execution context that&#39;s created by invoking a?</span></p><p class="c0"><span class="c1">Execution context for running the a function.</span></p><p class="c0"><span class="c1">Now let&#39;s take a look.</span></p><p class="c0"><span class="c1">It&#39;s also the Window object.</span></p><p class="c0"><span class="c1">So when you create a function, the this keyword is still going to</span></p><p class="c0"><span class="c1">point to the global object.</span></p><p class="c0"><span class="c1">If you decided to use this, if you&#39;re simply invoking the function.</span></p><p class="c0"><span class="c1">Similarly, if I use a function expression</span></p><p class="c0"><span class="c1">to set up the object, and then set that equal to a variable.</span></p><p class="c0"><span class="c1">Actually I mean this.</span></p><p class="c0"><span class="c1">So, var b gets this function expression to declare it, to create it.</span></p><p class="c0"><span class="c1">What will this be in that case?</span></p><p class="c0"><span class="c1">Well, I&#39;ll go ahead and</span></p><p class="c0"><span class="c1">invoke b, using the variable name to point to that function.</span></p><p class="c0"><span class="c1">And it&#39;s still Window.</span></p><p class="c0"><span class="c1">So whenever I create a function</span></p><p class="c0"><span class="c1">that&#39;s simply a function expression or a function statement.</span></p><p class="c0"><span class="c1">Creating a function at this level in the code,</span></p><p class="c0"><span class="c1">then this will point to the global object.</span></p><p class="c0"><span class="c1">And that&#39;s true even though there&#39;s actually</span></p><p class="c0"><span class="c1">three execution contexts that we see here.</span></p><p class="c0"><span class="c1">The global one, then the one that&#39;s created when a is invoked, and</span></p><p class="c0"><span class="c1">another execution context that&#39;s created when b is invoked.</span></p><p class="c0"><span class="c1">And in each of those cases, they get their own this keyword.</span></p><p class="c0"><span class="c1">But in all those cases, the keyword points to the same address,</span></p><p class="c0"><span class="c1">the same location in your computer&#39;s memory.</span></p><p class="c0"><span class="c1">So they&#39;re all pointing at the global object.</span></p><p class="c0"><span class="c1">Makes sense?</span></p><p class="c0"><span class="c1">That means you could even do strange things like this.newvariable</span></p><p class="c0"><span class="c1">let&#39;s say equals hello.</span></p><p class="c0"><span class="c1">I&#39;ve attached it to the global object.</span></p><p class="c0"><span class="c1">So after I call a, I could actually console.log newvariable.</span></p><p class="c0"><span class="c1">Cuz that&#39;s been created and using the dot operator,</span></p><p class="c0"><span class="c1">I&#39;ve attached a new variable to the global object.</span></p><p class="c0"><span class="c1">And remember,</span></p><p class="c0"><span class="c1">any variables attached to the global object, I can just reference like that.</span></p><p class="c0"><span class="c1">I don&#39;t need to use the dot operator.</span></p><p class="c0"><span class="c1">It just assumes I&#39;m asking for a variable on the global object.</span></p><p class="c0"><span class="c1">So I can refresh this and</span></p><p class="c0"><span class="c1">actually see that hello, kind of strange.</span></p><p class="c0"><span class="c1">If you don&#39;t understand what this keyword is pointing to and</span></p><p class="c0"><span class="c1">you think you&#39;re somehow attaching this to the function, you&#39;re not.</span></p><p class="c0"><span class="c1">You&#39;re actually crashing into the global namespace and</span></p><p class="c0"><span class="c1">you could cause yourself a lot of problems.</span></p><p class="c0"><span class="c1">So when you&#39;re just invoking the function, this points to the global variable.</span></p><p class="c0"><span class="c1">However, you may have seen something that looks like this when learning JavaScript.</span></p><p class="c0"><span class="c1">We&#39;re gonna talk about that later in the course about what circumstance</span></p><p class="c0"><span class="c1">when you would use the this variable inside a function like this.</span></p><p class="c0"><span class="c1">Now that said, what about an object method?</span></p><p class="c0"><span class="c1">Let me create a little space here and I&#39;ll create a new object literal and</span></p><p class="c0"><span class="c1">now that we understand function expressions,</span></p><p class="c0"><span class="c1">I can do something that we haven&#39;t done before inside an object literal.</span></p><p class="c0"><span class="c1">I can create a method.</span></p><p class="c0"><span class="c1">Remember, if the value is a primitive, it&#39;s called a property.</span></p><p class="c0"><span class="c1">And if the value a function, it&#39;s called a method.</span></p><p class="c0"><span class="c1">So, I&#39;ll create a name-value pair.</span></p><p class="c0"><span class="c1">I&#39;ll just call it name, so we can recognize the object and</span></p><p class="c0"><span class="c1">I&#39;ll call it the c object and then a comma and I&#39;ll create a method.</span></p><p class="c0"><span class="c1">I&#39;ll do log: so that&#39;s the name and</span></p><p class="c0"><span class="c1">then the value I want to create a function object.</span></p><p class="c0"><span class="c1">So, I&#39;ll just use a function expression.</span></p><p class="c0"><span class="c1">An anonymous function, no name and</span></p><p class="c0"><span class="c1">then I&#39;ll console.log this and</span></p><p class="c0"><span class="c1">then I&#39;ll call c.log So</span></p><p class="c0"><span class="c1">now I can invoke the function that was created inside this object literal,</span></p><p class="c0"><span class="c1">which is attached to this log.</span></p><p class="c0"><span class="c1">So this is the log method of the object c.</span></p><p class="c0"><span class="c1">See that?</span></p><p class="c0"><span class="c1">What will this turn out to be?</span></p><p class="c0"><span class="c1">Remember every time a function is invoked, a new execution context is created and</span></p><p class="c0"><span class="c1">the JavaScript engine decides what that keyword,</span></p><p class="c0"><span class="c1">the keyword this should be pointing to.</span></p><p class="c0"><span class="c1">In these other cases, it was the window object.</span></p><p class="c0"><span class="c1">But in this case, it&#39;s a method on an object and</span></p><p class="c0"><span class="c1">that means, see that there at the bottom?</span></p><p class="c0"><span class="c1">In the case where a function is actually a method</span></p><p class="c0"><span class="c1">attached to an object, this keyword becomes</span></p><p class="c0"><span class="c1">the object that that method is sitting inside of c.</span></p><p class="c0"><span class="c1">See that?</span></p><p class="c0"><span class="c1">These functions, this keyword.</span></p><p class="c0"><span class="c1">The JavaScript engine said, you&#39;re attached to an object.</span></p><p class="c0"><span class="c1">So when you see, when you use the this keyword I&#39;m going to</span></p><p class="c0"><span class="c1">be pointing at that very object that contains you.</span></p><p class="c0"><span class="c1">So I could actually say,</span></p><p class="c0"><span class="c1">this.name = &#39;Updated c object&#39;</span></p><p class="c0"><span class="c1">And then when this is logged, see that?</span></p><p class="c0"><span class="c1">I changed that property on this parent object,</span></p><p class="c0"><span class="c1">the object that holds the function.</span></p><p class="c0"><span class="c1">So that&#39;s useful.</span></p><p class="c0"><span class="c1">I can mutate that is change the object,</span></p><p class="c0"><span class="c1">that contains me if I&#39;m a method of that object by using of this keyword.</span></p><p class="c0"><span class="c1">You can imagine that can be very useful to be able to access other properties and</span></p><p class="c0"><span class="c1">methods on the same object that a particular method lives on.</span></p><p class="c0"><span class="c1">This is very common to use and it&#39;s neat.</span></p><p class="c0"><span class="c1">Now there&#39;s one more thing to show you and</span></p><p class="c0"><span class="c1">this a lot of people feel is a bug in JavaScript.</span></p><p class="c0"><span class="c1">Now you might be saying, what do you mean a bug in JavaScript?</span></p><p class="c0"><span class="c1">Well, JavaScript is a programming language and the engines and the language was</span></p><p class="c0"><span class="c1">designed by people and so decisions were made about how things should work.</span></p><p class="c0"><span class="c1">And in this one case, this decision a lot of people feel is wrong.</span></p><p class="c0"><span class="c1">Let me show you.</span></p><p class="c0"><span class="c1">Let&#39;s suppose that I create a function inside this method, we can do that right.</span></p><p class="c0"><span class="c1">I&#39;m gonna call it setname, I&#39;ll use a variable and</span></p><p class="c0"><span class="c1">I&#39;ll set a function expression.</span></p><p class="c0"><span class="c1">This time, I&#39;ll pass a variable to my function.</span></p><p class="c0"><span class="c1">Let&#39;s say, new name.</span></p><p class="c0"><span class="c1">I can do that.</span></p><p class="c0"><span class="c1">And inside here, I&#39;m gonna say this.name = newname.</span></p><p class="c0"><span class="c1">So, I&#39;m trying to update or</span></p><p class="c0"><span class="c1">mutate my object with this newname.</span></p><p class="c0"><span class="c1">And then let&#39;s say that here,</span></p><p class="c0"><span class="c1">I&#39;m going to go ahead and call setname and</span></p><p class="c0"><span class="c1">I&#39;ll say &#39;Updated again!</span></p><p class="c0"><span class="c1">The c object&#39;) and</span></p><p class="c0"><span class="c1">then console.log(this) again.</span></p><p class="c0"><span class="c1">So I mutate it and I should see &#39;Updated c object&#39;.</span></p><p class="c0"><span class="c1">I create a function that also, well when executed, create a new execution context.</span></p><p class="c0"><span class="c1">And I would expect, personally that this keyword would</span></p><p class="c0"><span class="c1">still point to the containing object,</span></p><p class="c0"><span class="c1">because it&#39;s a function inside of a function, inside of an object.</span></p><p class="c0"><span class="c1">And since this keyword points to the object, I would expect, well, one more</span></p><p class="c0"><span class="c1">function down and it&#39;ll still point to the object and I can mutate it, change it.</span></p><p class="c0"><span class="c1">So I would expect that after calling this setname function,</span></p><p class="c0"><span class="c1">I&#39;ll see updated again the c object as the name on that second console.log.</span></p><p class="c0"><span class="c1">Let&#39;s try it.</span></p><p class="c0"><span class="c1">Well, that&#39;s a problem.</span></p><p class="c0"><span class="c1">&quot;Updated c object&quot; and Updated c object&quot;.</span></p><p class="c0"><span class="c1">Meaning, this ran, but</span></p><p class="c0"><span class="c1">this didn&#39;t seem to do anything or did it.</span></p><p class="c0"><span class="c1">Oh, let&#39;s try going back and taking a look</span></p><p class="c0"><span class="c1">at the window object, the global object.</span></p><p class="c0"><span class="c1">And if I take a good look, look at that.</span></p><p class="c0"><span class="c1">See that?</span></p><p class="c0"><span class="c1">That name property here was instead created and</span></p><p class="c0"><span class="c1">added by the equals operator on the global object.</span></p><p class="c0"><span class="c1">That means that this internal function, when its execution</span></p><p class="c0"><span class="c1">context was created, the this key word points to the global object,</span></p><p class="c0"><span class="c1">even though it&#39;s sitting kind of inside an object that I created.</span></p><p class="c0"><span class="c1">I think that&#39;s wrong and a lot of people do, but</span></p><p class="c0"><span class="c1">that&#39;s the way JavaScript works in this case and</span></p><p class="c0"><span class="c1">there&#39;s not a lot we can do about it at this point.</span></p><p class="c0"><span class="c1">So what can we do when I have this kind of scenario?</span></p><p class="c0"><span class="c1">To make sure that I&#39;m using the right object.</span></p><p class="c0"><span class="c1">That this keyword isn&#39;t causing me to make an unintended error.</span></p><p class="c0"><span class="c1">Well there&#39;s a very common pattern that we can use in this case.</span></p><p class="c0"><span class="c1">And we&#39;ll understand it because We understand</span></p><p class="c0"><span class="c1">that objects are set by reference.</span></p><p class="c0"><span class="c1">Now that we understand that, we can understand this pattern.</span></p><p class="c0"><span class="c1">I can simply say I&#39;m going to set a variable.</span></p><p class="c0"><span class="c1">I&#39;ll call it self.</span></p><p class="c0"><span class="c1">Some people call it that, but I like self.</span></p><p class="c0"><span class="c1">Because I&#39;m inside this object.</span></p><p class="c0"><span class="c1">And I&#39;m going to set that equal to this.</span></p><p class="c0"><span class="c1">It was the very first line of my object method.</span></p><p class="c0"><span class="c1">So what happened right here?</span></p><p class="c0"><span class="c1">Well, now we have a new variable called self, and</span></p><p class="c0"><span class="c1">since these are objects, it&#39;s going to be set equal to by reference.</span></p><p class="c0"><span class="c1">So self will be pointing at the same location in memory as the this keyword.</span></p><p class="c0"><span class="c1">And right now, the this keyword on this line of code is pointing to</span></p><p class="c0"><span class="c1">my whole object.</span></p><p class="c0"><span class="c1">And then for sanity&#39;s sake, we simply use self everywhere where we normally</span></p><p class="c0"><span class="c1">would have used this, even inside these sub-functions.</span></p><p class="c0"><span class="c1">That way I don&#39;t have to think about, am I pointing to the right object?</span></p><p class="c0"><span class="c1">This is still pointing.</span></p><p class="c0"><span class="c1">The self variable is still pointing to the same location in memory as this.</span></p><p class="c0"><span class="c1">So when I mutate it, when I change it, when I add something to it or change it or</span></p><p class="c0"><span class="c1">whatever, it&#39;s going to update the appropriate thing,</span></p><p class="c0"><span class="c1">in this case, my whole object.</span></p><p class="c0"><span class="c1">So self, I can log that, and then when I look</span></p><p class="c0"><span class="c1">at this new function that I created, and this gets executed right here.</span></p><p class="c0"><span class="c1">I don&#39;t even worry about the this variable.</span></p><p class="c0"><span class="c1">I simply say self.</span></p><p class="c0"><span class="c1">So what&#39;s going to happen?</span></p><p class="c0"><span class="c1">Well, self isn&#39;t declared inside this function.</span></p><p class="c0"><span class="c1">So the JavaScript engine will look down the scope chain.</span></p><p class="c0"><span class="c1">Where is this function sitting physically in the code?</span></p><p class="c0"><span class="c1">Well, right inside here.</span></p><p class="c0"><span class="c1">So we can see that&#39;ll it just go outside to the next area outside, the outer</span></p><p class="c0"><span class="c1">lexical reference, and look for it, a variable called self and it will find it.</span></p><p class="c0"><span class="c1">And so this right here, the self variable inside this function,</span></p><p class="c0"><span class="c1">will end up being this one here.</span></p><p class="c0"><span class="c1">And that&#39;s still pointing to my whole object.</span></p><p class="c0"><span class="c1">So I can mutate my object here, as well.</span></p><p class="c0"><span class="c1">So now, this should show up properly.</span></p><p class="c0"><span class="c1">I have a proper reference to my object.</span></p><p class="c0"><span class="c1">And then I just use it from there on out, just for sanity&#39;s sake, so</span></p><p class="c0"><span class="c1">I don&#39;t have to think about it.</span></p><p class="c0"><span class="c1">And then I&#39;ll mutate it, I&#39;ll change it.</span></p><p class="c0"><span class="c1">And then I&#39;ll create a function, and</span></p><p class="c0"><span class="c1">I&#39;ll call that function and that will mutate the object.</span></p><p class="c0"><span class="c1">And I&#39;ll put it again.</span></p><p class="c0"><span class="c1">So this time I should see, look at that.</span></p><p class="c0"><span class="c1">That&#39;s proper.</span></p><p class="c0"><span class="c1">That&#39;s what I expected.</span></p><p class="c0"><span class="c1">So what did we learn?</span></p><p class="c0"><span class="c1">We learned that no programming language is perfect.</span></p><p class="c0"><span class="c1">They all have their quirks, and JavaScript certainly isn&#39;t an exception.</span></p><p class="c0"><span class="c1">But there are patterns we can use to get around</span></p><p class="c0"><span class="c1">any problems the programming language might have.</span></p><p class="c0"><span class="c1">Now I also wanna make mention that this pattern you&#39;ll see very often if</span></p><p class="c0"><span class="c1">you&#39;re working in any real-world JavaScript scenarios.</span></p><p class="c0"><span class="c1">However, the let keyword, which will be an alternative</span></p><p class="c0"><span class="c1">to the var keyword, is meant to clear some of these problems up.</span></p><p class="c0"><span class="c1">So as that becomes available in modern browsers,</span></p><p class="c0"><span class="c1">and depending on the kind of project you&#39;re working on,</span></p><p class="c0"><span class="c1">if you&#39;re working on a web project and you don&#39;t have to worry about older browsers.</span></p><p class="c0"><span class="c1">That&#39;s something that you&#39;ll soon start to be able to use,</span></p><p class="c0"><span class="c1">and bonus lectures in this course will help with that, as time goes on.</span></p><p class="c0"><span class="c1">But for now, realize that this pattern is a good one.</span></p><p class="c0"><span class="c1">It is used quite often and is quite useful.</span></p><p class="c0"><span class="c1">So we&#39;ve seen the this key word.</span></p><p class="c0"><span class="c1">It&#39;s the global variable, or</span></p><p class="c0"><span class="c1">the global object, when just invoking a function like this.</span></p><p class="c0"><span class="c1">And when the function is a method of an object,</span></p><p class="c0"><span class="c1">the this keyword points to the object.</span></p><p class="c0"><span class="c1">However, any internal functions have a problem.</span></p><p class="c0"><span class="c1">So we can use this concept of setting a variable equal to this,</span></p><p class="c0"><span class="c1">and then just carrying that with us the rest of the way to</span></p><p class="c0"><span class="c1">make sure that we don&#39;t run across any unintentional errors,</span></p><p class="c0"><span class="c1">or somehow throw things onto the global object that we didn&#39;t mean to.</span></p><p class="c0"><span class="c1">All right, let&#39;s move on.</span></p><p class="c4"><span class="c2"></span></p></body></html>