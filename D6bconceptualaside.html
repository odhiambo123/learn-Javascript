<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#29303b;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.5pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:8pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{background-color:#e6f2f5}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c4"><p class="c1"><span class="c0">It&#39;s time for a very important conceptual aside.</span></p><p class="c1"><span class="c0">This is, by value versus by reference, and</span></p><p class="c1"><span class="c0">understanding this concept will be important.</span></p><p class="c1"><span class="c0">Not only for your Java script development skills, and debugging skills,</span></p><p class="c1"><span class="c0">but also for some important things we&#39;re going to talk about in just a bit.</span></p><p class="c1"><span class="c0">So let&#39;s explain what we mean when we say by value and by reference.</span></p><p class="c1"><span class="c0">In both cases, we&#39;re talking about variables.</span></p><p class="c1"><span class="c0">So let&#39;s say I have a primitive value.</span></p><p class="c1"><span class="c0">One of those primitive types, a number, or a bullion, or a string.</span></p><p class="c1"><span class="c0">And, I&#39;ve set a variable equal to it.</span></p><p class="c1"><span class="c0">So, now that variable, let&#39;s say a, has an address location,</span></p><p class="c1"><span class="c0">where it knows where that primitive value sits, in memory.</span></p><p class="c1"><span class="c0">Remember, we said that the reference is really to a location in memory.</span></p><p class="c1"><span class="c0">And let&#39;s suppose then I run b = a.</span></p><p class="c1"><span class="c0">I set up a new variable, and it&#39;s equal to a.</span></p><p class="c1"><span class="c0 c3">Or maybe I pass a to a function, and the parameter name, and the function is b.</span></p><p class="c1"><span class="c0">If it&#39;s a primitive value in JavaScript, this is what happens.</span></p><p class="c1"><span class="c0">B, the new variable, points to a new address.</span></p><p class="c1"><span class="c0">A new location in memory.</span></p><p class="c1"><span class="c0">And a copy of the primitive value is placed into that spot in memory.</span></p><p class="c1"><span class="c0">So if a is 3, it sits in one address.</span></p><p class="c1"><span class="c0">One location in memory.</span></p><p class="c1"><span class="c0">B then also, will point to 3 for the copy, a separate location,</span></p><p class="c1"><span class="c0">in memory, that has been filled with that same value.</span></p><p class="c1"><span class="c0">This approach is called by value.</span></p><p class="c1"><span class="c0">I&#39;m passing, or referencing, or</span></p><p class="c1"><span class="c0">setting equal one value to another, by copying the value.</span></p><p class="c1"><span class="c0">These two variables become the same,</span></p><p class="c1"><span class="c0">by copying the value into two separate spots in memory.</span></p><p class="c1"><span class="c0">Make sense?</span></p><p class="c1"><span class="c0">Now, if i have an object in JavaScript, and this goes for all objects,</span></p><p class="c1"><span class="c0">that includes functions which are special types of objects and others.</span></p><p class="c1"><span class="c0">When I set a variable equal to an object, I still get a location,</span></p><p class="c1"><span class="c0">an address in memory that it knows where that object lives.</span></p><p class="c1"><span class="c0">And that&#39;s how I reference it.</span></p><p class="c1"><span class="c0">But when b is set equal to a, when I&#39;m essentially</span></p><p class="c1"><span class="c0">trying to get those two to be the same value, or I pass a to a function,</span></p><p class="c1"><span class="c0">that new variable b, instead of getting a new location in memory,</span></p><p class="c1"><span class="c0">simply points to the same location in memory that a does.</span></p><p class="c1"><span class="c0">No new object is created.</span></p><p class="c1"><span class="c0">No copy of the object is created.</span></p><p class="c1"><span class="c0">Instead, two names point to the same address.</span></p><p class="c1"><span class="c0">This would like if you had two names, an alias.</span></p><p class="c1"><span class="c0">And yet, both of those names,</span></p><p class="c1"><span class="c0">it doesn&#39;t matter because you still live in the same place.</span></p><p class="c1"><span class="c0">In this way, both a and b, have the same value,</span></p><p class="c1"><span class="c0">because when you ask them what their value is, they look at the same place in memory.</span></p><p class="c1"><span class="c0">This is called by reference.</span></p><p class="c1"><span class="c0">And by reference behaves quite differently from by value.</span></p><p class="c1"><span class="c0">It&#39;s important to understand that all objects interact by reference,</span></p><p class="c1"><span class="c0">when sending them equal to each other, or passing to a function.</span></p><p class="c1"><span class="c0">And this can cause problems if you don&#39;t understand this,</span></p><p class="c1"><span class="c0">weird problems that can be hard to debug.</span></p><p class="c1"><span class="c0">But once you do understand it, it becomes quite clear.</span></p><p class="c1"><span class="c0">All right.</span></p><p class="c1"><span class="c0">Let&#39;s look at some examples.</span></p><p class="c1"><span class="c0">All right, first let&#39;s talk about by value.</span></p><p class="c1"><span class="c0">And we&#39;re talking about primitive types in JavaScript, so</span></p><p class="c1"><span class="c0">I&#39;ll just put a comment here.</span></p><p class="c1"><span class="c0">And let&#39;s create two variables.</span></p><p class="c1"><span class="c0">I&#39;ll create a variable a, which I&#39;ll set equal to 3, and a variable b,</span></p><p class="c1"><span class="c0">which I won&#39;t set equal to anything, and then I&#39;ll set b equal to a.</span></p><p class="c1"><span class="c0">So, at this point, what should happen?</span></p><p class="c1"><span class="c0">Well, you can guess, that a will be 3, and b will be 3 as well.</span></p><p class="c1"><span class="c0">But remember, this is by value, because 3 is a primitive type, a number.</span></p><p class="c1"><span class="c0">The same would be true with any of the other primitive types that we discussed.</span></p><p class="c1"><span class="c0">So when b is set equal to a, the equal&#39;s operator,</span></p><p class="c1"><span class="c0">seeing that these are primitive types, creates a new spot in memory for b,</span></p><p class="c1"><span class="c0">copies that value from a, and sets it to that value that b is looking at.</span></p><p class="c1"><span class="c0">So b will be 3, and a will be 3, but</span></p><p class="c1"><span class="c0">they will be copies of each other, sitting in two spots in memory.</span></p><p class="c1"><span class="c0">That means that, after the fact, I can change a, and it doesn&#39;t affect b.</span></p><p class="c1"><span class="c0">Because they&#39;re two different spots in memory.</span></p><p class="c1"><span class="c0">This line copied them, but after that they&#39;re on their own.</span></p><p class="c1"><span class="c0">So let&#39;s run this.</span></p><p class="c1"><span class="c0">And what I should see, is what?</span></p><p class="c1"><span class="c0">What do you think I should see here?</span></p><p class="c1"><span class="c0">Knowing that these are two separate copies in memory.</span></p><p class="c1"><span class="c0">Well a is equal to 2, what will b be?</span></p><p class="c1"><span class="c0">B, its value is 3.</span></p><p class="c1"><span class="c0">And that makes sense, because b was just a copy of a.</span></p><p class="c1"><span class="c0">It has its own space in memory.</span></p><p class="c1"><span class="c0">So when I changed a, it didn&#39;t have any impact on b at all.</span></p><p class="c1"><span class="c0">That&#39;s by value.</span></p><p class="c1"><span class="c0">Next is by reference.</span></p><p class="c1"><span class="c0">So, I&#39;ll put a comma in here, so we can separate these, and that&#39;s all objects.</span></p><p class="c1"><span class="c0">That includes functions.</span></p><p class="c1"><span class="c0">So, this is the behavior in Java script for any type of object.</span></p><p class="c1"><span class="c0">So, I&#39;ll do a new variable c,</span></p><p class="c1"><span class="c0">I&#39;ll use object literal syntax to create a name, and value pair.</span></p><p class="c1"><span class="c0">And then a second variable, and I&#39;ll do the same thing.</span></p><p class="c1"><span class="c0">I&#39;ll set d equal to c.</span></p><p class="c1"><span class="c0">Now, what&#39;s happened at this point, at this line of code?</span></p><p class="c1"><span class="c0">The equals operator sees that these are objects.</span></p><p class="c1"><span class="c0">And so, rather than setting up d with a new memory space.</span></p><p class="c1"><span class="c0">It simply points d at the same address,</span></p><p class="c1"><span class="c0">at the same location in memory, that c points to.</span></p><p class="c1"><span class="c0">So if I was to output these two, you&#39;d see the same value, but</span></p><p class="c1"><span class="c0">they aren&#39;t copies of each other.</span></p><p class="c1"><span class="c0">They&#39;re simply pointing to the same spot in memory.</span></p><p class="c1"><span class="c0">That means, if I mutate C,</span></p><p class="c1"><span class="c0">lets say I change its dot greeting equal to hello,</span></p><p class="c1"><span class="c0">because now that I&#39;ve got my object setup I can use the dot operator, and</span></p><p class="c1"><span class="c0">say hello, and I&#39;ll mutate it, oh.</span></p><p class="c1"><span class="c0">Oh yeah, wait a second.</span></p><p class="c1"><span class="c0">Big word alert.</span></p><p class="c1"><span class="c0">Yeah, this is another one of those words that computer scientists decide</span></p><p class="c1"><span class="c0">to use that&#39;s way more complicated sounding then it really is.</span></p><p class="c1"><span class="c0">All right.</span></p><p class="c1"><span class="c0">Mutate.</span></p><p class="c1"><span class="c0">To change something.</span></p><p class="c1"><span class="c0">I know, right?</span></p><p class="c1"><span class="c0">That&#39;s all it means.</span></p><p class="c1"><span class="c0">And if you read up on any deep Java Strip subjects,</span></p><p class="c1"><span class="c0">you&#39;ll probably hear this word, mutate an object.</span></p><p class="c1"><span class="c0">Mutate a value.</span></p><p class="c1"><span class="c0">It just means change it.</span></p><p class="c1"><span class="c0">That&#39;s literally all it means.</span></p><p class="c1"><span class="c0">And you&#39;ll also see the phrase immutable,</span></p><p class="c1"><span class="c0">which simply means that it can&#39;t be changed.</span></p><p class="c1"><span class="c0">But that&#39;s a subject for another course.</span></p><p class="c1"><span class="c0">Mutate means to change something.</span></p><p class="c1"><span class="c0">So when I say, I mutate my object, that really means I&#39;m changing it.</span></p><p class="c1"><span class="c0">Maybe adding a property, removing a property,</span></p><p class="c1"><span class="c0">changing a value of a property, and mutate it.</span></p><p class="c1"><span class="c0">All right.</span></p><p class="c1"><span class="c0">So, here I&#39;ve mutated my object.</span></p><p class="c1"><span class="c0">That is, I have an object in memory, with a property called greeting,</span></p><p class="c1"><span class="c0">whose value is hi, and I change that properties value to hello.</span></p><p class="c1"><span class="c0">I mutate it.</span></p><p class="c1"><span class="c0">So now, I&#39;m going to console dot log d or c, and then d.</span></p><p class="c1"><span class="c0">Let&#39;s do that.</span></p><p class="c1"><span class="c0">What do you expect to see here?</span></p><p class="c1"><span class="c0">Remember that when you set values equal to each other, when it comes to objects,</span></p><p class="c1"><span class="c0">you&#39;re simply pointing the two variable names at the same location in memory.</span></p><p class="c1"><span class="c0">I have an object with a name value pair greeting, initially hi,</span></p><p class="c1"><span class="c0">and that&#39;s what it is when d is set equal to c.</span></p><p class="c1"><span class="c0">And then I use c to change the value of that property.</span></p><p class="c1"><span class="c0">So what am I going to see when I output these two?</span></p><p class="c1"><span class="c0">Well, I see hello for</span></p><p class="c1"><span class="c0">c, and hello for d.</span></p><p class="c1"><span class="c0">Does that surprise you?</span></p><p class="c1"><span class="c0">Well it shouldn&#39;t, understanding how this works.</span></p><p class="c1"><span class="c0">They&#39;re simply both pointing to the same location in memory.</span></p><p class="c1"><span class="c0">So if I change the value of that object, if I change,</span></p><p class="c1"><span class="c0">if I mutate that object, it doesn&#39;t matter which variable name I use,</span></p><p class="c1"><span class="c0">these are just aliases, for all intents and purposes.</span></p><p class="c1"><span class="c0">I&#39;m saying, at this memory location that C points to,</span></p><p class="c1"><span class="c0">change the greeting property of that object to hello.</span></p><p class="c1"><span class="c0">And then, when I go ask to look at d, d is pointing at that same location in memory.</span></p><p class="c1"><span class="c0">And it&#39;s been changed.</span></p><p class="c1"><span class="c0">So these are the same.</span></p><p class="c1"><span class="c0">So, with by reference, objects, since they&#39;re set equal to</span></p><p class="c1"><span class="c0">each other by reference, once you change one, you change the other, or all of them.</span></p><p class="c1"><span class="c0">If I had more variables set equal to c or d, they would all change,</span></p><p class="c1"><span class="c0">no matter which one I used to change it.</span></p><p class="c1"><span class="c0">Because they all would be pointing, at the same location and memory.</span></p><p class="c1"><span class="c0">The same thing happens when I do parameters to functions.</span></p><p class="c1"><span class="c0">So, even as parameters, objects are passed by reference,</span></p><p class="c1"><span class="c0">primitives by value but objects by reference.</span></p><p class="c1"><span class="c0">So, let&#39;s say, I write a new function called changeGreeting.</span></p><p class="c1"><span class="c0">I&#39;ll just call it, obj for object.</span></p><p class="c1"><span class="c0">And I&#39;ll expect that it has a greeting property.</span></p><p class="c1"><span class="c0">And I&#39;ll set it equal to Hola.</span></p><p class="c1"><span class="c0">So here again, I&#39;m mutating that object.</span></p><p class="c1"><span class="c0">So I have this d variable.</span></p><p class="c1"><span class="c0">It&#39;s pointing at the same memory space as c.</span></p><p class="c1"><span class="c0">Now it&#39;s set equal to hello.</span></p><p class="c1"><span class="c0">So, this time I&#39;ll call changeGreeting, and</span></p><p class="c1"><span class="c0">I&#39;ll pass d to this function.</span></p><p class="c1"><span class="c0">So d will be passed to here, that will be what obj is.</span></p><p class="c1"><span class="c0">And then I mutate it.</span></p><p class="c1"><span class="c0">So let&#39;s output c and d.</span></p><p class="c1"><span class="c0">What do you expect to see?</span></p><p class="c1"><span class="c0">We understand that just like equals, passing an object to</span></p><p class="c1"><span class="c0">a function means they&#39;re being passed by reference, not by value.</span></p><p class="c1"><span class="c0">So, obj will simply point to the same memory location as d, and</span></p><p class="c1"><span class="c0">d already points to the same memory location as c.</span></p><p class="c1"><span class="c0">So when this is mutated, meaning go update that object sitting there in that</span></p><p class="c1"><span class="c0">memory location, and I go output these, there we go.</span></p><p class="c1"><span class="c0">Hola for both c and d.</span></p><p class="c1"><span class="c0">Because I&#39;ve mutated the value in that particular memory space.</span></p><p class="c1"><span class="c0">Again, by reference.</span></p><p class="c1"><span class="c0">Now, one other thing to note, the equals operator sets up new memory space.</span></p><p class="c1"><span class="c0">That is a new address in memory.</span></p><p class="c1"><span class="c0">So, if I set c equal to an equivalent object, but</span></p><p class="c1"><span class="c0">I give it a different value, say howdy, and then I&#39;ll just copy, paste these.</span></p><p class="c1"><span class="c0">I copy and paste c and d.</span></p><p class="c1"><span class="c0">This equals, in this case, I&#39;m setting c equal to a new value.</span></p><p class="c1"><span class="c0">And so, the equals operator is going to, in this case,</span></p><p class="c1"><span class="c0">set up a brand new memory space for c, and put this value in it.</span></p><p class="c1"><span class="c0">So, d and c, will no longer be pointing, to the same location and memory.</span></p><p class="c1"><span class="c0">So, I get howdy, and d is still pointing at the spot that said hola.</span></p><p class="c1"><span class="c0">So, this is a special case, where my reference doesn&#39;t really apply,</span></p><p class="c1"><span class="c0">because the equals operator saw that these aren&#39;t a preexisting location in memory.</span></p><p class="c1"><span class="c0">This is a brand new object being created on the fly, by this object literal syntax.</span></p><p class="c1"><span class="c0">So, since it saw that its second parameter wasn&#39;t an object that already existed</span></p><p class="c1"><span class="c0">in memory, it had to set up a spot in memory for this to live.</span></p><p class="c1"><span class="c0">So, it set up that spot in memory for this to live, and then pointed c at it.</span></p><p class="c1"><span class="c0">In the earlier case, where I set d equal to c, c already existed.</span></p><p class="c1"><span class="c0">So the equals operator said, oh, this already exists in memory.</span></p><p class="c1"><span class="c0">It&#39;s an object, so I&#39;ll just point d to that same location.</span></p><p class="c1"><span class="c0">But again, here, this didn&#39;t exist in memory yet.</span></p><p class="c1"><span class="c0">It added it, and then pointed c there.</span></p><p class="c1"><span class="c0">So c is pointing now to a different spot in memory then d.</span></p><p class="c1"><span class="c0">So that&#39;s the exception there.</span></p><p class="c1"><span class="c0">Again, it&#39;s important for</span></p><p class="c1"><span class="c0">you to understand the difference between by value, and by reference.</span></p><p class="c1"><span class="c0">In some programming languages, you can actually</span></p><p class="c1"><span class="c0">decide whether something is passed by value or reference, with your code syntax.</span></p><p class="c1"><span class="c0">But in JavaScript you don&#39;t have that option.</span></p><p class="c1"><span class="c0">All primitive types are by value, and all objects are by reference.</span></p><p class="c1"><span class="c0">This can cause some errors and bugs that are hard to track down,</span></p><p class="c1"><span class="c0">if you don&#39;t understand this.</span></p><p class="c1"><span class="c0">But once you do, once you understand that if you&#39;re using objects,</span></p><p class="c1"><span class="c0">they&#39;re being mutated, then all the objects, all the variables,</span></p><p class="c1"><span class="c0">that point to that same object, are going to get that change.</span></p><p class="c1"><span class="c0">Going to see that change, cuz they&#39;re just pointing at the same memory space.</span></p><p class="c1"><span class="c0">You&#39;ll understand, if maybe, you accidentally mutated an object,</span></p><p class="c1"><span class="c0">that you didn&#39;t mean to.</span></p><p class="c1"><span class="c0">Because maybe you passed the object by reference, and didn&#39;t realize it.</span></p><p class="c1"><span class="c0">On the other hand, maybe you intended to change a primitive type, but you didn&#39;t</span></p><p class="c1"><span class="c0">change the original value, because it was being passed around by value.</span></p><p class="c1"><span class="c0">All right so, take a look at this code.</span></p><p class="c1"><span class="c0">It&#39;s provided for you to download.</span></p><p class="c1"><span class="c0">Or try typing it out yourself.</span></p><p class="c1"><span class="c0">Try messing around with it a bit.</span></p><p class="c1"><span class="c0">Understand all of these scenarios.</span></p><p class="c1"><span class="c0">This will help you greatly in debugging your own JavaScript code, and</span></p><p class="c1"><span class="c0">providing you some interesting options in the code that you write.</span></p><p class="c1"><span class="c0">And will also help you understand some things we&#39;ll see</span></p><p class="c1"><span class="c0">just a little bit later in the course.</span></p><p class="c1"><span class="c0">So that&#39;s by value, and by reference.</span></p><p class="c2"><span class="c5"></span></p></body></html>